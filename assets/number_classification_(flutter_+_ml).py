# -*- coding: utf-8 -*-
"""Number Classification (Flutter + ML).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xKHlpNtOKrBzd59UYt8dUXNobLGXku-8

# _MNIST Digits Classification_

## Imports
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import keras
from keras.models import Sequential
from keras.layers import Dense, Dropout
from sklearn.metrics import confusion_matrix
import seaborn as sns
from PIL import Image

np.random.seed(0)

"""## Data"""

from keras.datasets import mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

print(x_train.shape, y_train.shape)
print(x_test.shape, y_test.shape)

print(x_train.dtype)
print(y_train.dtype)

print(x_train[0].dtype)

"""## Visualize Dataset Samples"""

num_classes = 10
# f -> Figure
# ax -> Axes
f, ax = plt.subplots(1, num_classes, figsize=(20,20))

for i in range(0, num_classes):
  sample = x_train[y_train == i][0]
  ax[i].imshow(sample, cmap='gray')
  ax[i].set_title('Label: {}'.format(i), fontsize=16)

"""## Validate the classes of the labels
Instead of floating points, we make them vectors
"""

y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)


for i in range(10):
  print(y_train[i])

"""## Prepare the Data"""

# Normalize data
x_train = x_train / 255.0
x_test = x_test / 255.0

# Reshape the data
x_train = x_train.reshape(x_train.shape[0], -1)
x_test = x_test.reshape(x_test.shape[0], -1)
print(x_train.shape)

"""## Create the Model
A Neural Network will be used
"""

sq = Sequential()
sq.add(Dense(units=128, input_shape=(784,), activation='relu'))
sq.add(Dense(units=128, activation='relu'))
sq.add(Dropout(0.25))
sq.add(Dense(units=10, activation='softmax'))

sq.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
sq.summary()

"""## Train the Model"""

batch_size = 512
epochs = 10

sq.fit(x=x_train, y=y_train, batch_size=batch_size, epochs=epochs)

"""## Evaluate the Model"""

test_loss, test_accuracy = sq.evaluate(x_test, y_test)
print('Test loss: ', test_loss)
print('Test accuracy: ', test_accuracy)

y_pred = sq.predict(x_test)
y_pred_classes = np.argmax(y_pred, axis=1)
print('y_pred: ', y_pred)
print('y_pred_classes: ', y_pred_classes)
print('shape of y_pred_classes: ', y_pred_classes.shape)

# Single example
random_index = np.random.choice(len(x_test))
x_sample = x_test[random_index]
y_true = np.argmax(y_test, axis=1)
y_sample_true = y_true[random_index]
y_sample_pred_classes = y_pred_classes[random_index]

plt.title('Predicted: {}, True Value: {}'.format(y_sample_pred_classes, y_sample_true), fontsize=15)
plt.imshow(x_sample.reshape(28, 28), cmap='gray')

"""## Create a Confusion Matrix"""

cm = confusion_matrix(y_true, y_pred_classes)

# Plot
fig, ax = plt.subplots(figsize=(15, 10))
ax = sns.heatmap(cm, annot=True, fmt='d', ax=ax, cmap="Blues")
ax.set_xlabel('Predicted Label')
ax.set_ylabel('True Label')
ax.set_title('Confusion Matrix');

"""## Investigate Errors"""

errors = (y_pred_classes - y_true != 0)
y_pred_classes_errors = y_pred_classes[errors]
y_pred_errors = y_pred[errors]
y_true_errors = y_true[errors]
x_test_errors = x_test[errors]

y_pred_errors_probability = np.max(y_pred_errors, axis=1)
true_probability_errors = np.diagonal(np.take(y_pred_errors, y_true_errors, axis=1))
diff_errors_pred_true = y_pred_errors_probability - true_probability_errors

# Get list of indices of sorted differences
sorted_index_diff_errors = np.argsort(diff_errors_pred_true)
top_index_diff_errors = sorted_index_diff_errors[-5:] # last 5

# Show Top Errors
num = len(top_index_diff_errors)
f, ax = plt.subplots(1, num, figsize=(30, 30))

for i in range(0, num):
  index = top_index_diff_errors[i]
  sample = x_test_errors[index].reshape(28,28)
  y_t = y_true_errors[index]
  y_p = y_pred_classes_errors[index]
  ax[i].imshow(sample, cmap='gray')
  ax[i].set_title('Predicted label: {}\nTrue label: {}'.format(y_p, y_t), fontsize=20)

"""## Predict values of images"""

print(x_test[0].dtype)

img = Image.open('test1.png').convert('L')

arr = np.array(img)
inverted_arr = np.invert(arr)
x_eval = inverted_arr/255.0
print(x_eval.dtype)
plt.imshow(x_eval.reshape(28, 28), cmap='gray')

x_eval = x_eval.reshape(1, 784)
prediction = sq.predict(x_eval)

predicted_class = np.argmax(prediction)
print(predicted_class)

"""## Driver Code for predicting user defined images
Limitations:
- Works only on black ink against a white background
- Works only on a single digit
"""

img = Image.open('test4.png').convert('L')
img = img.resize((28, 28))
x_eval = np.array(img)
x_eval = np.invert(x_eval)
x_eval = x_eval/255.0
x_eval_reshape = x_eval.reshape(1, 784)
prediction = sq.predict(x_eval_reshape)
print(prediction)
predicted_class = np.argmax(prediction)
plt.title('Predicted: {}'.format(predicted_class), fontsize=20)
plt.imshow(x_eval.reshape(28, 28), cmap='gray')

"""## Save the model"""

sq.save('number_classification_model.h5')